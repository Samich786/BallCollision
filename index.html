<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Circle Clone Game (Winner Center + Responsive Badges)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    canvas{image-rendering:crisp-edges;image-rendering:pixelated}
    .mini-badge{ font-size:10px; line-height:1.1; }
    .pe-none { pointer-events:none; }
    .pe-auto { pointer-events:auto; }
  </style>
</head>
<body class="min-h-screen bg-black text-white flex items-center justify-center p-4">
  <div class="w-full max-w-6xl flex justify-center">
    <div class="relative w-full max-w-[800px]">
      <!-- CIRCLE -->
      <div class="relative mx-auto aspect-square">
        <canvas id="arena" class="w-full h-full block rounded-full relative"></canvas>

        <!-- START overlay -->
        <div id="start-overlay" class="absolute inset-0 flex items-center justify-center pe-none">
          <button id="start-btn"
            class="px-6 py-3 rounded-xl bg-emerald-500 hover:bg-emerald-600 text-black font-semibold shadow-lg pe-auto">
            Start
          </button>
        </div>

        <!-- WINNER overlay (dead center + a bit wider) -->
        <!-- WINNER overlay (always centered, responsive width) -->
<div id="overlay" class="absolute inset-0 hidden flex items-center justify-center bottom-10">
  <div class="bg-zinc-900/80 border border-zinc-700 rounded-2xl px-6 py-5 text-center w-[320px] sm:w-[320px]">
    <div id="overlay-emoji" class="text-7xl mb-2">💀</div>
    <div id="overlay-lines" class="space-y-1 text-xl"></div>
  </div>
</div>


      <!-- Scoreboard (desktop: right side, mobile: below in row) -->
      <div id="badges"
           class="flex gap-2 mt-2 sm:mt-0 sm:flex-col sm:absolute sm:top-1/2 sm:-translate-y-1/2 sm:right-[-72px] cursor-pointer
                  justify-center sm:justify-start">
        <div class="mini-badge flex items-center gap-1 bg-zinc-900/60 rounded-lg px-2 py-1">
          <img id="img1-display" src="" class="w-6 h-6 rounded-full border border-emerald-500 object-cover"/>
          <div class="flex flex-col items-center sm:items-start">
            <span id="name1" class="opacity-80 underline decoration-dotted cursor-pointer">Image 1</span>
            <span id="score1" class="font-bold">0</span>
          </div>
        </div>
        <div class="mini-badge flex items-center gap-1 bg-zinc-900/60 rounded-lg px-2 py-1">
          <img id="img2-display" src="" class="w-6 h-6 rounded-full border border-sky-500 object-cover"/>
          <div class="flex flex-col items-center sm:items-start">
            <span id="name2" class="opacity-80 underline decoration-dotted cursor-pointer">Image 2</span>
            <span id="score2" class="font-bold">0</span>
          </div>
        </div>
      </div>

      <!-- Controls (hidden after start, toggle with badges) -->
      <div id="controls" class="mt-3 flex flex-wrap items-center gap-2 justify-center text-xs transition-opacity duration-200">
        <label class="flex items-center gap-2 bg-zinc-900/60 rounded-lg px-3 py-2">
          <span class="opacity-80">Img 1</span>
          <input id="img1-input" type="file" accept="image/*"
            class="block w-32 text-xs file:mr-2 file:py-1.5 file:px-2
            file:rounded-md file:border-0 file:text-xs file:font-semibold
            file:bg-emerald-600 file:text-white hover:file:bg-emerald-700"/>
        </label>
        <label class="flex items-center gap-2 bg-zinc-900/60 rounded-lg px-3 py-2">
          <span class="opacity-80">Img 2</span>
          <input id="img2-input" type="file" accept="image/*"
            class="block w-32 text-xs file:mr-2 file:py-1.5 file:px-2
            file:rounded-md file:border-0 file:text-xs file:font-semibold
            file:bg-sky-600 file:text-white hover:file:bg-sky-700"/>
        </label>
        <button id="toggle-btn" class="px-3 py-2 rounded-lg bg-amber-500 hover:bg-amber-600 text-black font-semibold">Pause</button>
        <button id="reset-btn"  class="px-3 py-2 rounded-lg bg-zinc-800 hover:bg-zinc-700">Reset</button>
        <button id="dot-btn"    class="px-3 py-2 rounded-lg bg-yellow-500 hover:bg-yellow-400 text-black font-semibold">Reposition Dot</button>
        <span class="opacity-50">Tip: double-click a sprite or click a name to rename</span>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Config =====
  const MAX_SPRITES = 60;
  const START_SPEED = [340, 420]; // faster motion
  const SPRITE_RADIUS = 15;
  const DOT_RADIUS = 6;
  const ARENA_PADDING = 6;
  const BG = "#000";
  const RING = "rgba(255,255,255,0.12)";
  const DOT_COLOR = "#FFD21E";
  const FREEZE_THRESHOLD = MAX_SPRITES - 2;

  // ===== DOM =====
  const canvas = document.getElementById("arena");
  const ctx = canvas.getContext("2d");
  const startOverlay = document.getElementById("start-overlay");
  const startBtn = document.getElementById("start-btn");
  const toggleBtn = document.getElementById("toggle-btn");
  const resetBtn  = document.getElementById("reset-btn");
  const dotBtn    = document.getElementById("dot-btn");
  const controls  = document.getElementById("controls");
  const badgesWrap= document.getElementById("badges");

  const img1Input = document.getElementById("img1-input");
  const img2Input = document.getElementById("img2-input");
  const img1Display = document.getElementById("img1-display");
  const img2Display = document.getElementById("img2-display");
  const score1El = document.getElementById("score1");
  const score2El = document.getElementById("score2");
  const name1El = document.getElementById("name1");
  const name2El = document.getElementById("name2");

  // Single overlay (desktop + mobile)
  const overlay = document.getElementById("overlay");
  const overlayEmoji = document.getElementById("overlay-emoji");
  const overlayLines = document.getElementById("overlay-lines");

  const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));

  // ===== Sizing =====
  let W,H,center,arenaR;
  function resize(){
    const r = canvas.getBoundingClientRect();
    W = Math.floor(r.width*dpr);
    H = Math.floor(r.height*dpr);
    canvas.width=W; canvas.height=H;
    center = {x:W/2,y:H/2};
    arenaR = Math.min(W,H)/2 - ARENA_PADDING*dpr;
  }
  resize(); addEventListener("resize", resize);

  // ===== Assets =====
  const img1 = new Image();
  const img2 = new Image();
  const SKULL = new Image(); SKULL.crossOrigin = "anonymous";
  const DISGUISE = new Image(); DISGUISE.crossOrigin = "anonymous";
  SKULL.src = "https://twemoji.maxcdn.com/v/latest/svg/1f480.svg";   // 💀
  DISGUISE.src = "https://twemoji.maxcdn.com/v/latest/svg/1f978.svg"; // 🥸

  const def1 = "data:image/svg+xml;utf8,"+encodeURIComponent(
    `<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><circle cx='32' cy='32' r='31' fill='#006a4e'/></svg>`);
  const def2 = "data:image/svg+xml;utf8,"+encodeURIComponent(
    `<svg xmlns='http://www.w3.org/2000/svg' width='64' height='64'><circle cx='32' cy='32' r='31' fill='#ce1126'/></svg>`);
  img1.src = def1; img2.src = def2;
  img1Display.src = def1; img2Display.src = def2;

  img1Input.addEventListener("change", e=> loadTo(img1, img1Display, e.target.files?.[0]));
  img2Input.addEventListener("change", e=> loadTo(img2, img2Display, e.target.files?.[0]));
  function loadTo(image, display, file){
    if(!file) return;
    const url = URL.createObjectURL(file);
    image.onload = ()=> URL.revokeObjectURL(url);
    image.src = url; display.src = url;
  }

  // ===== Team Names =====
  let name1 = "Image 1";
  let name2 = "Image 2";
  function setTeamName(type, newName){
    if(!newName) return;
    if(type===1){ name1=newName; name1El.textContent=newName; }
    else { name2=newName; name2El.textContent=newName; }
  }
  name1El.addEventListener("click", ()=> setTeamName(1, prompt("Enter team name:", name1)));
  name2El.addEventListener("click", ()=> setTeamName(2, prompt("Enter team name:", name2)));

  // ===== Math =====
  const rand=(a,b)=>a+Math.random()*(b-a);
  const len=(v)=>Math.hypot(v.x,v.y);
  const norm=(v)=>{const L=len(v)||1; return {x:v.x/L,y:v.y/L};};
  const dot=(a,b)=>a.x*b.x+a.y*b.y;

  // ===== Collisions =====
  function resolveCollision(a,b){
    const n = {x: b.pos.x - a.pos.x, y: b.pos.y - a.pos.y};
    const dist = len(n) || 1;
    const minD = a.r + b.r;
    const overlap = minD - dist;
    if (overlap > 0) {
      const nHat = {x:n.x/dist, y:n.y/dist};
      const push = (overlap/2) + 0.5;
      a.pos.x -= nHat.x*push; a.pos.y -= nHat.y*push;
      b.pos.x += nHat.x*push; b.pos.y += nHat.y*push;
    }
    const nhat = norm({x:b.pos.x - a.pos.x, y:b.pos.y - a.pos.y});
    const va = a.vel, vb = b.vel;
    const va_n = dot(va, nhat);
    const vb_n = dot(vb, nhat);
    const va_prime = { x: va.x + (vb_n - va_n)*nhat.x, y: va.y + (vb_n - va_n)*nhat.y };
    const vb_prime = { x: vb.x + (va_n - vb_n)*nhat.x, y: vb.y + (va_n - vb_n)*nhat.y };
    const jitter = 0.02;
    a.vel = { x: va_prime.x*(1+jitter*(Math.random()-0.5)), y: va_prime.y*(1+jitter*(Math.random()-0.5)) };
    b.vel = { x: vb_prime.x*(1+jitter*(Math.random()-0.5)), y: vb_prime.y*(1+jitter*(Math.random()-0.5)) };
  }

  // ===== World =====
  let sprites=[];
  let lastT = performance.now();
  let running=false;    // start paused
  let started=false;
  let gameOver=false;
  let winnerType=null;  // 1 or 2
  let dotPos={x:0,y:0};
  let dotCooldown=0;
  let controlsVisible=true;

  function placeDotRandom(){
    const m = 2*DOT_RADIUS*dpr;
    const r = arenaR - m;
    const ang = rand(0,Math.PI*2);
    const rad = rand(0, r*0.75);
    dotPos.x = center.x + Math.cos(ang)*rad;
    dotPos.y = center.y + Math.sin(ang)*rad;
  }

  function spawn(type,pos){
    if(sprites.length>=MAX_SPRITES || gameOver) return;
    const speed = rand(START_SPEED[0], START_SPEED[1]) * dpr;
    const ang = rand(0,Math.PI*2);
    const vel = {x:Math.cos(ang)*speed, y:Math.sin(ang)*speed};
    const p = pos || {
      x:center.x + Math.cos(rand(0,6.28))*(arenaR*0.4),
      y:center.y + Math.sin(rand(0,6.28))*(arenaR*0.4)
    };
    sprites.push({type, pos:p, vel, r:SPRITE_RADIUS*dpr, cooldown:0});
  }

  function softInit(){
    sprites=[]; winnerType=null; gameOver=false; running=false; started=false;
    overlay.classList.add("hidden");
    startOverlay.classList.remove("hidden");
    toggleBtn.textContent="Pause";
    img1Display.src = img1.src; img2Display.src = img2.src;
    name1El.textContent = name1; name2El.textContent = name2;
    score1El.textContent = "0"; score2El.textContent = "0";
    showControls(true);
    spawn(1); spawn(2); placeDotRandom();
  }
  softInit();

  // UI show/hide for clean recording
  function showControls(show){
    controlsVisible = show;
    if(show){
      controls.classList.remove("opacity-0","pointer-events-none");
    }else{
      controls.classList.add("opacity-0","pointer-events-none");
    }
  }
  badgesWrap.addEventListener("click", ()=> showControls(!controlsVisible));

  // Controls
  startBtn.addEventListener("click", ()=>{
    started=true; running=true;
    startOverlay.classList.add("hidden");
    showControls(false); // hide after start for clean view
  });
  toggleBtn.addEventListener("click", ()=>{
    if (!started || gameOver) return;
    running=!running;
    toggleBtn.textContent = running ? "Pause" : "Start";
  });
  resetBtn.addEventListener("click", softInit);
  dotBtn.addEventListener("click", ()=>{ if(started && !gameOver) placeDotRandom(); });

  // Double-click rename (works pre-start)
  canvas.addEventListener("dblclick", (e)=>{
    if (gameOver) return;
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.width / rect.width);
    const y = (e.clientY - rect.top) * (canvas.height / rect.height);
    for (let i=sprites.length-1; i>=0; i--){
      const s = sprites[i];
      const d2 = (x - s.pos.x)**2 + (y - s.pos.y)**2;
      if (d2 <= (s.r)**2){
        const current = s.type===1 ? name1 : name2;
        const newName = prompt("Enter team name:", current);
        setTeamName(s.type, newName);
        break;
      }
    }
  });

  // Winner freeze (centered card + correct in-circle icons)
  function endGame(score1, score2){
  gameOver = true;
  running = false;

  // decide winner (1, 2, or null for draw)
  let win = null;
  if (score1 > score2) win = 1;
  else if (score2 > score1) win = 2;

  // keep sprites as uploaded (no swap). winnerType not needed anymore,
  // but harmless if still set elsewhere.
  winnerType = win;

  // main big icon (💀 for win, 🤝 for draw)
  overlayEmoji.textContent = win ? "💀" : "🤝";

  // winner on top: "<ImageX> <name> Rocked 💀"
  // loser below:   "<ImageY> <name> Shocked 🥸"
  if (win === 1){
    overlayLines.innerHTML = `
      <div><span class="font-semibold">${name1}</span> Rocked 💀</div>
      <div><span class="font-semibold">${name2}</span> Shocked 🥸</div>
    `;
  } else if (win === 2){
    overlayLines.innerHTML = `
      <div><span class="font-semibold">${name2}</span> Rocked 💀</div>
      <div><span class="font-semibold">${name1}</span> Shocked 🥸</div>
    `;
  } else {
    // draw fallback
    overlayLines.innerHTML = `
      <div><span class="font-semibold">${name1}</span> 😐</div>
      <div><span class="font-semibold">${name2}</span> 😐</div>
    `;
  }

  overlay.classList.remove("hidden");
}

  // Main loop
  function frame(ts){
    const dt = Math.min(0.033, (ts - lastT)/1000);
    lastT = ts;
    dotCooldown = Math.max(0, dotCooldown - dt);

    if (running && !gameOver){
      // integrate + wall bounce + dot hit
      for (const s of sprites){
        s.pos.x += s.vel.x * dt;
        s.pos.y += s.vel.y * dt;

        // wall bounce
        const vC = {x:s.pos.x - center.x, y:s.pos.y - center.y};
        const dist = len(vC);
        const maxDist = arenaR - s.r;
        if (dist > maxDist){
          const n = norm(vC);
          s.pos.x = center.x + n.x*maxDist;
          s.pos.y = center.y + n.y*maxDist;
          const dp = dot(s.vel, n);
          s.vel = {x: s.vel.x - 2*dp*n.x, y: s.vel.y - 2*dp*n.y};
        }

        // dot hit -> clone + move dot
        if (s.cooldown>0) s.cooldown -= dt;
        const dDot = Math.hypot(s.pos.x - dotPos.x, s.pos.y - dotPos.y);
        if (dDot < s.r + DOT_RADIUS*dpr && s.cooldown<=0 && dotCooldown<=0){
          s.cooldown = 0.25; dotCooldown = 0.25;
          spawn(s.type, {x:s.pos.x, y:s.pos.y});
          placeDotRandom();
        }
      }

      // sprite-sprite collisions
      for (let i=0;i<sprites.length;i++){
        for (let j=i+1;j<sprites.length;j++){
          const a = sprites[i], b = sprites[j];
          const dx = b.pos.x - a.pos.x;
          const dy = b.pos.y - a.pos.y;
          const minD = a.r + b.r;
          if (dx*dx + dy*dy < minD*minD){ resolveCollision(a,b); }
        }
      }
    }

    // scores
    const score1 = sprites.filter(s=>s.type===1).length;
    const score2 = sprites.filter(s=>s.type===2).length;
    score1El.textContent = score1;
    score2El.textContent = score2;

    // near capacity => freeze
    if (!gameOver && sprites.length >= FREEZE_THRESHOLD){
      endGame(score1, score2);
    }

    // draw
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle=BG; ctx.fillRect(0,0,W,H);

    // arena
    ctx.beginPath();
    ctx.arc(center.x, center.y, arenaR, 0, Math.PI*2);
    ctx.strokeStyle=RING; ctx.lineWidth=2*dpr; ctx.stroke();

    // dot
    ctx.beginPath();
    ctx.arc(dotPos.x, dotPos.y, DOT_RADIUS*dpr, 0, Math.PI*2);
    ctx.fillStyle=DOT_COLOR; ctx.fill();

    // sprites (on gameOver: winner -> skull, loser -> disguise)
    for (const s of sprites){
  const r = s.r;
  const img = (s.type === 1 ? img1 : img2); // <— stays the same, no swap
  ctx.save();
  ctx.beginPath(); ctx.arc(s.pos.x, s.pos.y, r, 0, Math.PI*2); ctx.clip();
  ctx.drawImage(img, s.pos.x - r, s.pos.y - r, r*2, r*2);
  ctx.restore();

  ctx.beginPath(); ctx.arc(s.pos.x, s.pos.y, r, 0, Math.PI*2);
  ctx.strokeStyle = "rgba(255,255,255,0.6)"; ctx.lineWidth = 1*dpr; ctx.stroke();
}

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
})();
</script>

</body>
</html>
